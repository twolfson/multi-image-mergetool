doctype html
html
  head
    title multi-image-mergetool
    link(rel="stylesheet", href="https://cdn.rawgit.com/twbs/bootstrap/v3.3.7/dist/css/bootstrap.min.css", text="text/css")
    style.
      ul {
        /* Same width as `container-fluid` */
        padding-left: 15px;
      }

      /* Built on http://codepen.io/twolfson/pen/XjQdKL */
      .loading {
        /* Default to low opacity for browsers without keyframe support */
        opacity: 0.3;

        /* Add our animation */
        /* https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations */
        animation-duration: 0.5s;
        animation-name: loading;
        animation-iteration-count: infinite;
        animation-direction: alternate;
        animation-timing-function: linear;
      }

      @keyframes loading {
        from { opacity: 0.3; }
        to { opacity: 0.4; }
      }
    script(src="https://code.jquery.com/jquery-3.1.1.min.js", integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=", crossorigin="anonymous")
    script(src="https://cdn.rawgit.com/twbs/bootstrap/v3.3.7/dist/js/bootstrap.min.js")
    script(src="https://cdn.rawgit.com/jed/domo/13c45aba3e94dd2d1bc469ce3339bbc1e3a10314/lib/domo.js")
  body
    //- Expose our data directly to `window`
    script
      //- TODO: Make sure there are no XSS holes like `</script><script>alert(1)`
      | window.imageSets = !{JSON.stringify(image_sets)};

    //- TODO: Consider scrollspy for update buttons
    //- TODO: Consider buttons to expand row of images to full screen
    //- TODO: Consider magnifying glass zoom on images (e.g. like in ecommerce sites)
    //- TODO: Figure out how to make selection work, maybe normal GUI like Gemini but with jawbone effect for matching items

    //- [x] TODO: Next: Add image acceptance support
    //- [x] TODO: Next: Add automatic image matching
    //- [ ] TODO: Next: Add image acceptance support for matched images
    //- [ ] TODO: Next: Filter out unselected matched images
    //- [ ] TODO: Next: Move to button triggered image matching
    //- [ ] TODO: Next: Add click/drag overlay support
    //- [ ] TODO: Next: Add result update (i.e. pass/fail) if we still lack it

    //- Define our initial render script
    //- TODO: Relocate into another file
    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Simplifiy domo reference
        var D = window.domo;

        // Generate our container element
        // DEV: We use a container element instead of the DOM directly to prevent redrawing elements on each append
        var containerEl = D.DIV({
          class: 'container-fluid'
        });

        // Expose our images
        // TODO: Expose images in tree list like gemini-gui, maybe even simplified variants like GitHub
        //   (e.g. `a/b/c` when only 1 file)
        var imgWidth = '400';
        var imageSets = window.imageSets;
        imageSets.forEach(function createImageSet (imgSet, i) {
          // Create local variables for our image set
          var imgSetId = imgSet.refImg;
          var imgSetHumanName = imgSet.refImg;

          // Generate our image set element
          // TODO: Show match pass/fail status (e.g. green/red)
          var imgSetEl = D.UL([
            D.LI([
              // Row title
              D.A({
                href: 'javascript:void 0;', 'data-toggle': 'collapse',
                'data-target': '[data-image-set="' + imgSetId + '"]', 'aria-controls': imgSetId
              }, imgSetHumanName),

              // Collapsable container for row
              // DEV: We use `data-id` as `id` has restrictions on characters
              D.DIV({
                // Make our first image set visible
                // TODO: Remove this flag, make only failing tests visible
                // DEV: If class names get too complex, use `classnames` library
                class: i === 0 ? 'collapse in well' : 'collapse well',
                'data-image-set': imgSetId
              }, [
                // Action buttons
                D.DIV([
                  D.BUTTON({
                    class: 'btn btn-default',
                    'data-action': 'accept-changes'
                  }, 'âœ“ Accept changes'),
                  ' ',
                  D.BUTTON({
                    class: 'btn btn-default',
                    'data-action': 'accept',
                    // TODO: Make our button disabled and only enable when an overlay is drawn
                    // TODO: When changes are accepted, reset all affected overlays and buttons
                    // disabled: 'disabled'
                  }, 'Find similar images with selection'),
                ]),

                // Image set
                D.TABLE({class: 'table'}, [
                  D.THEAD([
                    D.TR([
                      D.TH('Current:'),
                      D.TH('Diff:'),
                      D.TH('Ref:')
                    ])
                  ]),
                  D.TBODY([
                    D.TR([
                      D.TD({style: 'width: 33%'} ,[
                        D.IMG({
                          'data-compare-type': 'current',
                          src: '/images/' + encodeURIComponent(imgSet.currentImg),
                          style: 'width: 100%'
                        })
                      ]),
                      //- DEV: We use `width: 33%` to guarantee no widths change when we use a loading spinner or images are missing
                      D.TD({style: 'width: 33%'} ,[
                        D.IMG({
                          'data-compare-type': 'diff',
                          src: '/images/' + encodeURIComponent(imgSet.diffImg),
                          style: 'width: 100%',
                        })
                      ]),
                      D.TD({style: 'width: 33%'} ,[
                        D.IMG({
                          'data-compare-type': 'ref',
                          src: '/images/' + encodeURIComponent(imgSet.refImg),
                          style: 'width: 100%'
                        })
                      ])
                    ])
                  ])
                ])
              ]),
            ])
          ]);

          // Append our element to the container element
          containerEl.appendChild(imgSetEl);
        });

        // Apppend our container element
        document.body.appendChild(containerEl);
      });

    //- Define our button bindings
    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Define cache busting helper
        function cachebustImg($img) {
          var originalSrc = $img.attr('src');
          var newSrc = originalSrc.match(/\?1$/) ? originalSrc + '1' : originalSrc + '?1';
          $img.attr('src', newSrc);
        }

        // Define acceptance helper
        function acceptImageSetChanges(acceptedImgBase64, imgSetId) {
          // Fade out diff and reference images to "loading" state
          var $imgSet = $('[data-image-set="' + jQuery.escapeSelector(imgSetId) + '"]');
          //- assert.strictEqual($imgSet.length, 1);
          var $diffImg = $imgSet.find('[data-compare-type="diff"]');
          var $refImg = $imgSet.find('[data-compare-type="ref"]');
          $diffImg.addClass('loading');
          $refImg.addClass('loading');

          // TODO: Eagerly update our status
          //   This won't be the scenario for update reference image (i.e. we are progressively updating images)

          // Make an AJAX call to accept our image
          // http://api.jquery.com/jQuery.ajax/#jqXHR
          var jqXHR = $.post('/update-image-set/' + encodeURIComponent(imgSetId), {
            ref: acceptedImgBase64
          });

          // If there is an error
          jqXHR.fail(function handleFail (jqXHR, textStatus, errorThrown) {
            // TODO: Expose error to user so they can retry
            console.error('Error encountered "' + errorThrown + '" when updating image "' + imgSetId + '"');

            // TODO: Reset set status
          });

          // When loading completes, remove loading state and update image references
          jqXHR.always(function handleAlways (dataOrJqXHR, textStatus, jqXHROrErrorThrown) {
            $diffImg.removeClass('loading');
            $refImg.removeClass('loading');
            cachebustImg($diffImg);
            cachebustImg($refImg);
          });
        }

        // Define base64 content helper
        // TODO: Find a base64 content helper library?
        var base64CanvasEl = document.createElement('canvas');
        var base64Context = base64CanvasEl.getContext('2d');
        function getBase64Content(imgEl) {
          // Resize our canvas to target size
          var width = base64CanvasEl.width = imgEl.naturalWidth;
          var height = base64CanvasEl.height = imgEl.naturalHeight;

          // Clear our canvas to prevent legacy artifacts
          // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect
          // TODO: Test me that we clear legacy artifacts properly
          base64Context.clearRect(0, 0, width, height);

          // Draw our image and return its data URL
          // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
          // https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
          // DEV: We use `image/png` for lossless encoding which is necessary for visual comparison
          base64Context.drawImage(imgEl, 0, 0);
          return base64CanvasEl.toDataURL('image/png');
        }

        // Set up image acceptance binding
        $('body').on('click', 'button[data-action="accept-changes"]', function handleClick (evt) {
          // Find our image set container
          var btnEl = evt.target;
          var $imgSet = $(btnEl).closest('[data-image-set]');
          var imgSetId = $imgSet.data('image-set');
          //- assert.strictEqual($imgSet.length, 1);

          // Find the current image
          var $currentImg = $imgSet.find('[data-compare-type="current"]');
          //- assert.strictEqual($currentImg.length, 1);

          // Extract base64 content for image
          var base64Data = getBase64Content($currentImg[0]);

          // Run acceptance function
          acceptImageSetChanges(base64Data, imgSetId);
        });
      });

    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
      setTimeout(function waitForImagesToLoad () {
        // Simplifiy domo reference
        var D = window.domo;

        // Specify target area (this would be done via overlay selection)
        // DEV: Target area gathered from `/prototype`
        var targetArea = {left: 159, top: 0, width: 205, height: 63.133331298828125};

        // Specify expected diff image
        // TODO: Load expected diff image based on selected image
        // DEV: This loads first matching image only due to `querySelector` instead of `querySelectorAll`
        var expectedImgSetEl = document.querySelector('[data-image-set]');
        var expectedDiffImg = expectedImgSetEl.querySelector('[data-compare-type=diff]');
        var resultsEl = D.DIV([
          D.H4('Similar images:'),
          D.DIV([
            D.BUTTON({
              class: 'btn btn-default',
              'data-action': 'update-similar-images'
            }, 'âœ“ Update selected images'),
          ])
        ]);
        // TODO: Delete results element upon resolution
        expectedImgSetEl.appendChild(resultsEl);

        // Start our chain of methods
        findSelectionMatches();
        function findSelectionMatches() {
          // Start our performance check (70ms for 200 1024x1600 images)
          console.time('findSelectionMatches');

          // Find our sets of images to update
          var imageSetEls = document.querySelectorAll('[data-image-set]');
          imageSetEls = Array.prototype.slice.call(imageSetEls);

          // Remove original matching image set
          imageSetEls = imageSetEls.filter(function removeOriginalImageSet (imageSetEl) {
            return imageSetEl !== expectedImgSetEl;
          });

          // Convert image sets into objects so we can add metadata
          var imageSetInfos = imageSetEls.map(function createImageSetInfo (imageSetEl) {
            return {
              currentImg: imageSetEl.querySelector('[data-compare-type=current]'),
              diffImg: imageSetEl.querySelector('[data-compare-type=diff]'),
              refImg: imageSetEl.querySelector('[data-compare-type=ref]'),
              humanName: imageSetEl.getAttribute('data-image-set')
            };
          });

          // Prepare canvas for images to match against
          function getSelectionImageData(img) {
            // Generate our canvas sized down to the selection
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L14-L18
            var canvasEl = document.createElement('canvas');
            canvasEl.width = targetArea.width;
            canvasEl.height = targetArea.height;
            var context = canvasEl.getContext('2d');

            // Draw a clip as a performance precaution, then our image
            // DEV: We haven't tested if using a clip improves performance but assume it should
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
            context.rect(0, 0, targetArea.width, targetArea.height);
            context.clip();
            // TODO: Verify that drawing scaled images doesn't affect canvas drawing
            context.drawImage(img, -1 * targetArea.left, -1 * targetArea.top);

            // Return our generated canvas
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L19-L20
            return context.getImageData(0, 0, targetArea.width, targetArea.height).data;
          }

          // Reset HTML/CSS overrides
          // TODO: We should be able to remove overrides by using `naturalWidth`
          expectedDiffImg = expectedDiffImg.cloneNode();
          delete expectedDiffImg.height; delete expectedDiffImg.width;
          delete expectedDiffImg.style; delete expectedDiffImg.className;
          var expectedImageData = getSelectionImageData(expectedDiffImg);

          // Prepare deep equals helper
          // DEV: This is bad for security as we short circuit (i.e. not time constant comparison)
          function deepEquals(aArr, bArr) {
            if (aArr.length !== bArr.length) {
              return false;
            }
            var i = 0;
            for (; i < aArr.length; i += 1) {
              if (aArr[i] !== bArr[i]) {
                return false;
              }
            }
            return true;
          }

          // Filter image sets based on matching widths and selection
          var matchingImageSetInfos = imageSetInfos.filter(function matchImageSetInfo (imageSetInfo) {
            // If the images are different widths, return false
            // TODO: Allow this to be a configurable heuristic
            var actualDiffImg = imageSetInfo.diffImg;
            if (expectedDiffImg.naturalWidth !== actualDiffImg.naturalWidth) {
              return false;
            }

            // If the selection is different, return false
            // DEV: We current do an exact match but could move to other comparison script
            //   Unfortunately, Gemini's comparison seems to be Node.js only
            //   and an exact match is "good enough" for now
            var actualImageData = getSelectionImageData(actualDiffImg);
            if (!deepEquals(actualImageData, expectedImageData)) {
              return false;
            }

            // Otherwise, approve match
            return true;
          });

          // End our performance check
          console.timeEnd('findSelectionMatches');

          // Pass through matching sets to `bulkUpdateSelection`
          bulkUpdateSelection(matchingImageSetInfos);
        }

        function bulkUpdateSelection(imageSetInfos) {
          // Start our performance check (620ms total for 100 1024x1600 images, 400ms seems to be first `drawImage`)
          console.time('bulkUpdateSelection');

          // Find our output targets
          var resultsDocFrag = D.FRAGMENT();

          // Generate and updated ref image for each of our comparisons
          imageSetInfos.forEach(function generateUpdatedRef (imageSetInfo) {
            // Localize our references
            var currentImg = imageSetInfo.currentImg;
            var refImg = imageSetInfo.refImg;

            // Create a canvas
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L14-L18
            var canvasEl = document.createElement('canvas');
            canvasEl.width = refImg.naturalWidth;
            canvasEl.height = refImg.naturalHeight;
            var context = canvasEl.getContext('2d');

            // Load our reference into the canvas
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            context.drawImage(refImg, 0, 0);

            // Update our selected portion on reference and draw image in clipping
            // DEV: This is probably the most efficient way (outside of web workers) because
            //   we would have to draw image twice no matter what
            //   Maybe there's double pixel updates but I don't thinks so
            // DEV: Performance alternatives we thought of but aren't needed
            //   Extract image from 2nd canvas via `ndarray`
            //   Use web workers
            //   Requesting server do it via `get-pixels` and `save-pixels`
            // DEV: Slowest part is drawing initial image above
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
            context.rect(targetArea.left, targetArea.top, targetArea.width, targetArea.height);
            context.clip();
            context.drawImage(currentImg, 0, 0);

            // Duplicate reference image and shrink both canvas/image for output
            canvasEl.style.width = '100%';
            var refImgClone = refImg.cloneNode();
            refImgClone.style.width = '100%';

            // Generate and append result content
            // DEV: We use a document fragment to avoid `n` DOM edits -- instead it's 1
            // DEV: Tables will all use same width due to heuristics
            var resultGroupEl = D.TABLE({class: 'table'}, [
              D.THEAD([
                D.TR([
                  // TODO: Add collapse support like in `gemini-gui`
                  D.TH({colspan: 3}, imageSetInfo.humanName)
                ]),
                D.TR([
                  // TODO: Move style out of inline and to classes for more performance
                  // DEV: `min-width` is to give us spacing for "Save update text"
                  D.TD({style: 'padding-right: 10px; min-width: 120px;'}, 'Save update:'),
                  D.TD('Original ref:'),
                  D.TD('Updated ref:')
                ]),
              ]),
              D.TBODY([
                D.TR([
                  D.TD({
                    style: 'vertical-align: top;'
                  }, [
                    D.INPUT({type: 'checkbox', checked: true})
                  ]),
                  D.TD({style: 'vertical-align: top;'}, [refImgClone]),
                  D.TD({style: 'vertical-align: top;'}, [canvasEl])
                ])
              ])
            ]);
            resultsDocFrag.appendChild(resultGroupEl);
          });

          // Append aggregate content to DOM
          resultsEl.appendChild(resultsDocFrag);

          // End our performance check
          console.timeEnd('bulkUpdateSelection');
        }
      }, 500);
      });

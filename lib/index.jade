doctype html
html
  head
    title multi-image-mergetool
    link(rel="stylesheet", href="https://cdn.rawgit.com/twbs/bootstrap/v3.3.7/dist/css/bootstrap.min.css", text="text/css")
    style.
      ul {
        /* Same width as `container-fluid` */
        padding-left: 15px;
      }

      /* Built on http://codepen.io/twolfson/pen/XjQdKL */
      .loading {
        /* Default to low opacity for browsers without keyframe support */
        opacity: 0.3;

        /* Add our animation */
        /* https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations */
        animation-duration: 0.5s;
        animation-name: loading;
        animation-iteration-count: infinite;
        animation-direction: alternate;
        animation-timing-function: linear;
      }

      @keyframes loading {
        from { opacity: 0.3; }
        to { opacity: 0.4; }
      }
    script(src="https://code.jquery.com/jquery-3.1.1.min.js", integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=", crossorigin="anonymous")
    script(src="https://cdn.rawgit.com/twbs/bootstrap/v3.3.7/dist/js/bootstrap.min.js")
    script(src="https://cdn.rawgit.com/jed/domo/13c45aba3e94dd2d1bc469ce3339bbc1e3a10314/lib/domo.js")
  body
    //- Expose our data directly to `window`
    script
      //- TODO: Make sure there are no XSS holes like `</script><script>alert(1)`
      | window.imageSets = !{JSON.stringify(image_sets)};

    //- TODO: Consider scrollspy for update buttons
    //- TODO: Consider buttons to expand row of images to full screen
    //- TODO: Consider magnifying glass zoom on images (e.g. like in ecommerce sites)
    //- TODO: Figure out how to make selection work, maybe normal GUI like Gemini but with jawbone effect for matching items

    //- TODO: Next: Add image acceptance support
    //- TODO: Next: Add non-click image matching
    //- TODO: Next: Add image acceptance support for matched images
    //- TODO: Next: Move to click image matching
    //- TODO: Next: Add overlay support
    //- TODO: Next: Add result update (i.e. pass/fail) if we still lack it

    //- Define our main script
    //- TODO: Relocate into another file
    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Simplifiy domo reference
        var D = window.domo;

        // Generate our container element
        // DEV: We use a container element instead of the DOM directly to prevent redrawing elements on each append
        var containerEl = D.DIV({
          class: 'container-fluid'
        });

        // Expose our images
        // TODO: Expose images in tree list like gemini-gui, maybe even simplified variants like GitHub
        //   (e.g. `a/b/c` when only 1 file)
        var imgWidth = '400';
        var imageSets = window.imageSets;
        imageSets.forEach(function createImageSet (imgSet, i) {
          // Create local variables for our image set
          var imgSetId = imgSet.refImg;
          var imgSetHumanName = imgSet.refImg;

          // Generate our image set element
          // TODO: Move this to a constructor with methods that are run via Bootstrap bindings
          //   e.g. `click: [data-image-set] .btn[data-accept]` or something like that... I dislike `data-accept` but yea
          // TODO: Show match pass/fail status (e.g. green/red)
          var imgSetEl = D.UL([
            D.LI([
              // Row title
              D.A({
                href: 'javascript:void 0;', 'data-toggle': 'collapse',
                'data-target': '[data-id="' + imgSetId + '"]', 'aria-controls': imgSetId
              }, imgSetHumanName),

              // Collapsable container for row
              // DEV: We use `data-id` as `id` has restrictions on characters
              D.DIV({
                // Make our first image set visible
                // TODO: Remove this flag, make only failing tests visible
                // DEV: If class names get too complex, use `classnames` library
                class: i === 0 ? 'collapse in well' : 'collapse well',
                'data-image-set': imgSetId
              }, [
                // Action buttons
                D.DIV([
                  D.BUTTON({
                    class: 'btn btn-default',
                    'data-action': 'accept-changes'
                  }, 'âœ“ Accept changes'),
                  ' ',
                  D.BUTTON({
                    class: 'btn btn-default',
                    'data-action': 'accept',
                    // TODO: Make our button disabled and only enable when an overlay is drawn
                    // TODO: When changes are accepted, reset all affected overlays and buttons
                    // disabled: 'disabled'
                  }, 'Find similar images with selection'),
                ]),

                // Image set
                D.TABLE([
                  D.TR([
                    D.TD('Current:'),
                    D.TD('Diff:'),
                    D.TD('Ref:')
                  ]),
                  D.TR([
                    D.TD({style: 'width: 33%'} ,[
                      D.IMG({
                        'data-compare-type': 'current',
                        src: '/images/' + imgSet.currentImg,
                        style: 'width: 100%'
                      })
                    ]),
                    //- DEV: We use `width: 33%` to guarantee no widths change when we use a loading spinner or images are missing
                    D.TD({style: 'width: 33%'} ,[
                      // TODO: Ditch `expected-diff-img` as we have multiple images now
                      D.IMG({
                        'data-compare-type': 'diff',
                        src: '/images/' + imgSet.diffImg,
                        class: 'expected-diff-img',
                        style: 'width: 100%',
                      })
                    ]),
                    D.TD({style: 'width: 33%'} ,[
                      D.IMG({
                        'data-compare-type': 'ref',
                        src: '/images/' + imgSet.refImg,
                        style: 'width: 100%'
                      })
                    ])
                  ])
                ])
              ]),
            ])
          ]);

          // Append our element to the container element
          containerEl.appendChild(imgSetEl);
        });

        // Apppend our container element
        document.body.appendChild(containerEl);
      });

      // Define cache busting helper
      function cachebustImg($img) {
        var originalSrc = $img.attr('src');
        var newSrc = originalSrc.match(/\?1$/) ? originalSrc + '1' : originalSrc + '?1';
        $img.attr('src', newSrc);
      }

      // Define acceptance helper
      function acceptImageSetChanges(acceptedImgBase64, imgSetId) {
        // TODO: Make an AJAX call to accept our image

        // Fade out diff and reference images to "loading" state
        var $imgSet = $('[data-image-set="' + jQuery.escapeSelector(imgSetId) + '"]');
        //- assert.strictEqual($imgSet.length, 1);
        var $diffImg = $imgSet.find('[data-compare-type="diff"]');
        var $refImg = $imgSet.find('[data-compare-type="ref"]');
        $diffImg.addClass('loading');
        $refImg.addClass('loading');

        // TODO: Eagerly update our status
        //   This won't be the scenario for update reference image (i.e. we are progressively updating images)

        // TODO: If there is an error, reset our status

        // TODO: When loading completes, remove loading state and update image references
        //   This is development mocking for now
        setTimeout(function () {
          $diffImg.removeClass('loading');
          $refImg.removeClass('loading');
          cachebustImg($diffImg);
          cachebustImg($refImg);
        }, 1000);
      }

      // Define base64 content helper
      function getBase64Content(imgEl) {
        // TODO: Complete base64 extraction
        return '';
      }

      // Set up image acceptance binding
      $('body').on('click', 'button[data-action="accept-changes"]', function handleClick (evt) {
        // Find our image set container
        var btnEl = evt.target;
        var $imgSet = $(btnEl).closest('[data-image-set]');
        var imgSetId = $imgSet.data('image-set');
        //- assert.strictEqual($imgSet.length, 1);

        // Find the current image
        var $currentImg = $imgSet.find('[data-compare-type="current"]');
        //- assert.strictEqual($currentImg.length, 1);

        // TODO: Extract base64 content for image

        // Run acceptance function
        acceptImageSetChanges($currentImg[0], imgSetId);
      });

    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Simplifiy domo reference
        var D = window.domo;
        return;

        // Specify target area (this would be done via overlay selection)
        // DEV: Target area gathered from `/prototype`
        var targetArea = {left: 159, top: 0, width: 205, height: 63.133331298828125};

        // TODO: Realizing we need to do matching on similar content (i.e. same width image + same diff in selection)
        //   It looks like Gemini's comparison library isn't built for browser
        //     https://github.com/gemini-testing/looks-same
        //   For now, use direct comparison with `get-pixels` and `ndarray`
        //   Actually, we can prob use a second canvas with negative placement for x/y and same width/neight
        //     This is more future-proof and dodges loading `ndarray` dependencies
        //     Although, it's likely less efficient since we have to extract image data and compare it

        // Start our chain of methods
        findSelectionMatches();
        function findSelectionMatches() {
          // Start our performance check (70ms for 200 1024x1600 images)
          console.time('findSelectionMatches');

          // Find our sets of images to update
          var compareSetEls = document.querySelectorAll('[data-compare-set]');

          // Convert image sets into objects so we can add metadata
          var compareSets = Array.prototype.map.call(compareSetEls, function createCompareSet (compareSetEl, i) {
            return {
              currentImg: compareSetEl.querySelector('[data-compare-type=current]'),
              diffImg: compareSetEl.querySelector('[data-compare-type=diff]'),
              refImg: compareSetEl.querySelector('[data-compare-type=ref]'),
              name: 'path/to/image/' + i + '/Chrome'
            };
          });

          // Prepare canvas for images to match against
          function getSelectionImageData(img) {
            // Generate our canvas sized down to the selection
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L14-L18
            var canvasEl = document.createElement('canvas');
            canvasEl.width = targetArea.width;
            canvasEl.height = targetArea.height;
            var context = canvasEl.getContext('2d');

            // Draw a clip for safety (performanc), then our image
            // DEV: We haven't tested if this improves performance but assume it should
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
            context.rect(0, 0, targetArea.width, targetArea.height);
            context.clip();
            // TODO: Verify that drawing scaled images doesn't affect canvas drawing
            context.drawImage(img, -1 * targetArea.left, -1 * targetArea.top);

            // Return our generated canvas
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L19-L20
            return context.getImageData(0, 0, targetArea.width, targetArea.height).data;
          }
          var expectedDiffImg = document.querySelector('#expected-diff-img').cloneNode();
          // Reset HTML/CSS overrides
          delete expectedDiffImg.height; delete expectedDiffImg.width;
          delete expectedDiffImg.style; delete expectedDiffImg.className;
          var expectedImageData = getSelectionImageData(expectedDiffImg);

          // Prepare deep equals helper
          // DEV: This is bad for security as we short circuit (i.e. not time constant comparison)
          function deepEquals(aArr, bArr) {
            if (aArr.length !== bArr.length) {
              return false;
            }
            var i = 0;
            for (; i < aArr.length; i += 1) {
              if (aArr[i] !== bArr[i]) {
                return false;
              }
            }
            return true;
          }

          // Filter image sets based on matching widths and selection
          var matchingCompareSets = compareSets.filter(function matchCompareSet (compareSet) {
            // If the images are different widths, return false
            // TODO: Allow this to be a configurable heuristic
            var actualDiffImg = compareSet.diffImg;
            // TODO: Use `actualWidth`
            if (expectedDiffImg.width !== actualDiffImg.width) {
              return false;
            }

            // If the selection is different, return false
            // DEV: We current do an exact match but could move to other comparison script
            //   Unfortunately, Gemini's comparison seems to be Node.js only
            //   and an exact match is "good enough" for now
            var actualImageData = getSelectionImageData(actualDiffImg);
            if (!deepEquals(actualImageData, expectedImageData)) {
              return false;
            }

            // Otherwise, approve match
            return true;
          });

          // End our performance check
          console.timeEnd('findSelectionMatches');

          // Pass through matching sets to `bulkUpdateSelection`
          bulkUpdateSelection(matchingCompareSets);
        }

        function bulkUpdateSelection(compareSets) {
          // Start our performance check (620ms total for 100 1024x1600 images, 400ms seems to be first `drawImage`)
          console.time('bulkUpdateSelection');

          // Find our output targets
          var resultsEl = document.querySelector('#results');
          var resultsDocFrag = document.createDocumentFragment();

          // Generate and updated ref image for each of our comparisons
          compareSets.forEach(function generateUpdatedRef (compareSet) {
            // Localize our references
            var currentImg = compareSet.currentImg;
            var refImg = compareSet.refImg;

            // Create a canvas
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L14-L18
            var canvasEl = document.createElement('canvas');
            canvasEl.width = refImg.width;
            canvasEl.height = refImg.height;
            var context = canvasEl.getContext('2d');

            // Load our reference into the canvas
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            context.drawImage(refImg, 0, 0);

            // Update our selected portion on reference and draw image in clipping
            // DEV: This is probably the most efficient way (outside of web workers) because
            //   we would have to draw image twice no matter what
            //   Maybe there's double pixel updates but I don't thinks so
            // DEV: Performance alternatives we thought of but aren't needed
            //   Extract image from 2nd canvas via `ndarray`
            //   Use web workers
            //   Requesting server do it via `get-pixels` and `save-pixels`
            // DEV: Slowest part is drawing initial image above
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
            context.rect(targetArea.left, targetArea.top, targetArea.width, targetArea.height);
            context.clip();
            context.drawImage(currentImg, 0, 0);

            // Duplicate reference image and shrink both canvas/image for output
            var imgHeight = 250;
            canvasEl.style.height = imgHeight + 'px';
            var refImgClone = refImg.cloneNode();
            refImgClone.style.height = imgHeight + 'px';

            // Generate and append result content
            // DEV: We use a document fragment to avoid `n` DOM edits -- instead it's 1
            var resultGroupEl = D.DIV([
              D.TR([
                // TODO: Add collapse support like in `gemini-gui`
                D.TD({colspan: 3}, D.B(compareSet.name))
              ]),
              D.TR([
                // TODO: Move style out of inline and to classes for more performance
                D.TD({style: 'padding-right: 10px;'}, 'Save update:'),
                D.TD('Original ref:'),
                D.TD('Updated ref:')
              ]),
              D.TR([
                D.TD({
                  style: 'vertical-align: top;'
                }, [
                  D.INPUT({type: 'checkbox', checked: true})
                ]),
                D.TD([refImgClone]),
                D.TD([canvasEl])
              ])
            ]);
            resultsDocFrag.appendChild(resultGroupEl);

            // TODO: When bulk update is accepted, send overwrite requests to server with new image as "Ref"
            //   and use `?1` trick to refresh images
            //   then re-run comparisons for all current vs ref
            // DEV: We are realizing that Gemini likely does comparisons in Node.js so we should do the same on update
          });

          // Append aggregate content to DOM
          resultsEl.appendChild(resultsDocFrag);

          // End our performance check
          console.timeEnd('bulkUpdateSelection');
        }
      });

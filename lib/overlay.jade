doctype html
html
  head
    title gist-gemini-fancy prototype
    style.
      /* Guarantee overlays automatically include border in widths */
      * {
        box-sizing: border-box;
      }

      /* Perform nice resets */
      body {
        height: 100%;
        margin: 0;
        /* https://github.com/corysimmons/typographic/blob/2.9.3/scss/typographic.scss#L34 */
        font-family: 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif';
      }

      /* Overlay styles */
      .overlay-bound {
        /* http://chrisnager.github.io/cursors/ */
        cursor: crosshair;
      }
      .overlay {
        position: absolute;
        width: 50px;
        height: 50px;
        background: #33CC33;
        border: 2px solid #00FF00;
        opacity: 0.5;

        /* Allow click through for new selection */
        /* TODO: Depending on configuration, this could be a drag action on the overlay */
        pointer-events: none;
      }
  body
    //- Provide info to the user
    h1 gist-gemini-fancy prototype
    p
      | Click and drag over the image to generate an overlay
      br
      = "Overlay info: "
      span
        code#overlay-info null

    //- Load an images directly from our report
    //- img(src="gemini-report/images/root/default-large/Chrome~current.png")
    img(src="gemini-report/images/root/default-large/Chrome~diff.png")
    //- img(src="gemini-report/images/root/default-large/Chrome~ref.png")

    //- Place an overflow element for scroll testing
    div(style="width: 120vw; height: 100vh;") &nbsp;

    //- Load in our dependencies for `unidragger`
    script(src="https://cdn.rawgit.com/metafizzy/ev-emitter/v1.0.3/ev-emitter.js")
    script(src="https://cdn.rawgit.com/metafizzy/unipointer/v2.1.0/unipointer.js")
    script(src="https://cdn.rawgit.com/metafizzy/unidragger/v2.1.0/unidragger.js")

    //- Integrate HTML/CSS overlay for selection
    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Find our image
        var imgEl = document.querySelector('img');

        // Define our overlay class
        function Overlay(targetEl) {
          // Bind our overlay to the element
          this.handles = [targetEl];
          this.bindHandles();

          // Add an overlay binding class to our element
          targetEl.className += ' overlay-bound';

          // Calculate target dimensions
          // TODO: For wider browser support, see what `draggabilly` does (prob uses `get-size`)
          // bounds = {x, y, width, height, top, right, bottom, left}
          // http://youmightnotneedjquery.com/#offset
          // DEV: This is our poor man's `_.extend`
          var _bounds = targetEl.getBoundingClientRect();
          var bounds = this.bounds = {};
          ['x', 'y', 'width', 'height', 'top', 'right', 'bottom', 'left'].forEach(function copyKey (key) {
            bounds[key] = _bounds[key];
          });
          this.bounds.top += document.documentElement.scrollTop + document.body.scrollTop;
          this.bounds.left += document.documentElement.scrollLeft + document.body.scrollLeft;
        }
        // Inherit prototype from Unidragger
        Overlay.prototype = Object.create(Unidragger.prototype);
        Overlay.prototype.dragStart = function (evt, pointer) {
          // If we don't have an overlay element, create one now
          if (!this.overlayEl) {
            this.overlayEl = document.createElement('div');
            this.overlayEl.className = 'overlay';
            document.body.appendChild(this.overlayEl);
          }

          // Update our box position
          this.update(evt, pointer, {x: 0, y: 0});
        };
        Overlay.prototype.update = function (evt, pointer, moveVector) {
          // If the move vector's X dimension is normal
          // DEV: We use `pointerDownPoint` instead of `dragStartPoint` for better cursor positioning
          var left, top, width, height;
          if (moveVector.x >= 0) {
            left = this.pointerDownPoint.x;
            width = moveVector.x;
          // Otherwise (inverted), use opposite parameters)
          } else {
            // DEV: Technically we are subtracting moveVector as it's a negative value
            left = this.pointerDownPoint.x + moveVector.x;
            width = (-1 * moveVector.x);
          }

          // Similar behavior for Y dimension
          if (moveVector.y >= 0) {
            top = this.pointerDownPoint.y;
            height = moveVector.y;
          } else {
            top = this.pointerDownPoint.y + moveVector.y;
            height = (-1 * moveVector.y);
          }

          // Restrict our dimensions so we don't go out of bounds
          // DEV: We limit top/left first as height/width offsets are dependent
          if (top < this.bounds.top) {
            // Remove excess distance from height to account for overflow
            // height += 100 - 200 /* higher on page - lower on page */;
            height += top - this.bounds.top;
            top = this.bounds.top;
          }
          if (left < this.bounds.left) {
            width += left - this.bounds.left;
            left = this.bounds.left;
          }
          // bottomEdgeFromTop = 100 + 800 /* 900 */
          var bottomEdgeFromTop = this.bounds.top + this.bounds.height;
          if (top + height > bottomEdgeFromTop) {
            // height = 900 - 300 /* 600 */
            height = bottomEdgeFromTop - top;
          }
          var rightEdgeFromLeft = this.bounds.left + this.bounds.width;
          if (left + width > rightEdgeFromLeft) {
            width = rightEdgeFromLeft - left;
          }

          // Update our element position
          this.overlayEl.style.left = left + 'px';
          this.overlayEl.style.width = width + 'px';
          this.overlayEl.style.top = top + 'px';
          this.overlayEl.style.height = height + 'px';

          // Emit an update event
          this.emitEvent('change:overlay', [evt, pointer, {
            absolute: {
              left: left,
              width: width,
              top: top,
              height: height
            },
            relative: {
              left: left - this.bounds.left,
              width: width,
              top: top - this.bounds.top,
              height: height
            }
          }]);
        };
        Overlay.prototype.dragMove = function(evt, pointer, moveVector) {
          this.update(evt, pointer, moveVector);
        };

        // Make image draggable
        var imgOverlay = new Overlay(imgEl);

        // When our overlay moves, update the coordinates
        var overlayInfoEl = document.querySelector('#overlay-info');
        imgOverlay.on('change:overlay', function handleChangeOverlay (evt, pointer, overlayInfo) {
          var relativeInfo = overlayInfo.relative;
          overlayInfoEl.textContent = 'left:' + relativeInfo.left + ', ' +
            'top: ' + relativeInfo.top + ', ' +
            'width: ' + relativeInfo.width + ', ' +
            'height: ' + relativeInfo.height;
        });

        // TODO: Fake drag move for easier testing
        // https://github.com/twolfson/mockdesk/blob/0.14.2/lib/js/scripts/drag-rectangle.js
      });

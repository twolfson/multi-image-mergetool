doctype html
html
  head
    title gist-gemini-fancy performance
    style.
      /* Perform nice resets */
      body {
        height: 100%;
        margin: 0;
        /* https://github.com/corysimmons/typographic/blob/2.9.3/scss/typographic.scss#L34 */
        font-family: 'Helvetica Neue', 'Helvetica', 'Arial', 'sans-serif';
      }
  body
    //- Provide info to the user
    h1 gist-gemini-fancy performance
    p
      | This page is a proof of concept to verify we won't have performance issues with a lot of pages

    //- Load an images directly from our report
    table
      - var imgHeight = '250';
      tr
        td Current:
        td Diff:
        td Ref:
      tr
        td
          img(src="gemini-report/images/root/default-large/Chrome~current.png", height=imgHeight)
        td
          img(src="gemini-report/images/root/default-large/Chrome~diff.png", height=imgHeight)
        td
          img(src="gemini-report/images/root/default-large/Chrome~ref.png", height=imgHeight)

    //- Load large set of images in hidden container
    //- DEV: In reality, we would probably have something like Gemini's hidden selection
    div(style="display: none")
      - var i = 0;
      while (i < 100)
        div(data-compare-set=i)
          img(data-compare-type="current", src="gemini-report/images/root/default-large/Chrome~current.png")
          img(data-compare-type="diff", src="gemini-report/images/root/default-large/Chrome~diff.png")
          img(data-compare-type="ref", src="gemini-report/images/root/default-large/Chrome~ref.png")
        - i += 1

    //- Define an output area for images
    p(style="margin-bottom: 0") Results:
    table#results(style="margin-left: 20px")

    //- TODO: Consider scrollspy for update buttons
    //- TODO: Consider buttons to expand row of images to full screen
    //- TODO: Consider magnifying glass zoom on images (e.g. like in ecommerce sites)
    //- TODO: Figure out how to make selection work, maybe normal GUI like Gemini but with jawbone effect for matching items

    script(src="https://cdn.rawgit.com/jed/domo/13c45aba3e94dd2d1bc469ce3339bbc1e3a10314/lib/domo.js")
    script.
      document.addEventListener('DOMContentLoaded', function handleReady () {
        // Simplifiy domo reference
        var D = window.domo;

        // Define and run our update logic
        bulkUpdateSelection();
        function bulkUpdateSelection() {
          // Specify target area (this would be done via overlay selection)
          // DEV: Target area gathered from `/prototype`
          var targetArea = {left: 159, top: 0, width: 205, height: 63.133331298828125};

          // Find our sets of images to update
          var compareSetEls = document.querySelectorAll('[data-compare-set]');

          // Find our output targets
          var resultsEl = document.querySelector('#results');

          // TODO: Realizing we need to do matching on similar content (i.e. same width image + same diff in selection)
          //   It looks like Gemini's comparison library isn't built for browser
          //     https://github.com/gemini-testing/looks-same
          //   For now, use direct comparison with `get-pixels` and `ndarray`

          // Iterate over our sets
          Array.prototype.forEach.call(compareSetEls, function forEachCompareSetEl (compareSetEl, i) {
            // Find our source images
            var currentImg = compareSetEl.querySelector('[data-compare-type=current]');
            var refImg = compareSetEl.querySelector('[data-compare-type=ref]');

            // Create a canvas
            // https://github.com/scijs/get-pixels/blob/7c447cd979637b31e47e148f238a1e71611af481/dom-pixels.js#L14-L18
            var canvasEl = document.createElement('canvas');
            canvasEl.width = refImg.width;
            canvasEl.height = refImg.height;
            var context = canvasEl.getContext('2d');

            // Load our reference into the canvas
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
            context.drawImage(refImg, 0, 0);

            // Update our selected portion on reference and draw image in clipping
            // DEV: This is probably the most efficient way (outside of web workers) because
            //   we would have to draw image twice no matter what
            //   Maybe there's double pixel updates but I don't thinks so
            // DEV: Performance alternatives we thought of but aren't needed
            //   Extract image from 2nd canvas via `ndarray`
            //   Use web workers
            //   Requesting server do it via `get-pixels` and `save-pixels`
            // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rect
            context.rect(targetArea.left, targetArea.top, targetArea.width, targetArea.height);
            context.clip();
            context.drawImage(currentImg, 0, 0);

            // Duplicate reference image and shrink both canvas/image for output
            var imgHeight = 250;
            canvasEl.style.height = imgHeight + 'px';
            var refImgClone = refImg.cloneNode();
            refImgClone.style.height = imgHeight + 'px';

            // Generate and append result content
            var resultGroupEl = D.DIV([
              D.TR([
                // TODO: Add collapse support like in `gemini-gui`
                D.TD({colspan: 3}, D.B('path/to/image/' + i + '/Chrome'))
              ]),
              D.TR([
                // TODO: Move style out of inline and to classes for more performance
                D.TD({style: 'padding-right: 10px;'}, 'Save update:'),
                D.TD('Original:'),
                D.TD('Updated:')
              ]),
              D.TR([
                D.TD({
                  style: 'vertical-align: top;'
                }, [
                  D.INPUT({type: 'checkbox', checked: true})
                ]),
                D.TD([refImgClone]),
                D.TD([canvasEl])
              ])
            ]);
            resultsEl.appendChild(resultGroupEl);

            // TODO: When bulk update is accepted, send overwrite requests to server with new image as "Ref"
            //   and use `?1` trick to refresh images
            //   then re-run comparisons for all current vs ref
            // DEV: We are realizing that Gemini likely does comparisons in Node.js so we should do the same on update
          });
        }
      });
